# Java
<details>
  <summary>목차</summary>
  
- [Java 언어의 특징](#Java-언어의-특징)
- [객체와 클래스의 차이점](#객체와-클래스의-차이점)
- [객체지향 프로그래밍](#객체지향-프로그래밍)
  - [등장배경](#등장배경)
    - [순차적(비구조적) 프로그래밍](#순차적비구조적-프로그래밍)
    - [절차적(구조적) 프로그래밍](#절차적구조적-프로그래밍)
    - [객체지향 프로그래밍의 등장](#객체지향-프로그래밍의-등장)
  - [객체지향 프로그래밍의 4가지 특징](#객체지향-프로그래밍의-4가지-특징)
- [추상클래스와 인터페이스](#추상클래스와-인터페이스)
  
</details>

## Java 언어의 특징
C언어에 객체 지향적 기능을 추가하여 만든 C++과는 달리, Java는 처음부터 객체 지향 언어로 개발된 프로그래밍 언어이다. Java는 ***JVM***을 사용하여, 운영체제와 독립적으로 동작할 수 있다.
> ***JVM?***<br>
>> Java Virutal Machine(자바 가상 머신), OS에 종속받지 않고 CPU가 Java를 인식, 실행할 수 있게 하는 가상 컴퓨터
#### 장점
1. 운영체제와는 독립적으로 실행할 수 있다.
2. 불필요한 기능을 과감히 제거하여 다른 언어에 비해 배우기 쉽다.
3. 자동 메모리 관리 등을 지원하여 안정성이 높다.
4. 연산자 오버로딩을 금지하고 제네릭을 도입함으로써 코드의 가독성이 높였다.
#### 단점
1. 실행을 위해 JVM을 거쳐야 하므로, 다른 언어에 비해 실행 속도가 느리다.
2. 개발자가 일일이 예외 처리를 지정해 줘야 한다는 불편함이 있다.
3. 다른 언어에 비해 작성해야 할 코드가 길다.

## 객체와 클래스의 차이점
클래스는 객체의 설계도이며, 객체는 클래스를 이용해 생성한 실체이다. 즉, 객체는 클래스의 인스턴스이다.

## 객체지향 프로그래밍
객체 지향을 이해하기 위하여 객체지향 프로그래밍의 등장배경을 알아보고자 한다. 따라서 객체지향이 등장하기 이전의 프로그래밍 패러다임을 몇가지 살펴보자.
### 등장배경
#### 순차적(비구조적) 프로그래밍
정의한 기능의 흐름에 따라 순서대로 동작을 추가하며 프로그램을 완성하는 방식이다. 간단한 프로그램은 한 눈에 보이기 때문에 직관적이고 편할 것이다. 하지만 조금이라도 규모가 커지게 되면 복잡하게 된다. 예를 들어 A -> B -> C 라는 동작을 구현하다가 C에서 A로 돌아가야할 상황이 생기면 ```goto```를 활용해야 한다. <br>
코드가 더 복잡하게 되어 이를 무분별하게 활용하게 되면 흔히 말하는 스파게티 코드로 완성하게된다. 유일한 장점인 직관성 조차 없어지게 되는 것이다.
이에 등장한 프로그래밍이 **절차적, 구조적 프로그래밍**이다.
#### 절차적(구조적) 프로그래밍
절차적 프로그래밍에서 '절차'는 함수를 의미한다. 즉, 절차적 프로그래밍이란 반복되는 동작을 함수 및 ***프로시저*** 형태로 모듈화하여 사용하는 방식이다.
> ***프로시저?***<br>
>> 리턴 값이 없는 함수. 예를 들어 데이터를 출력하는 용도인 ```printf```와 같은 함수를 프로시저라고 한다.
절차적 프로그래밍은 반복 동작을 모듈화하여 코드를 많이 줄일 수 있다. 하지만 프로시저는 추상적이라는 단점이 있다.
<br>
예를 들어, 도서관의 도서관리 프로그램을 개발한다면,
1. '책'이라는 자료형을 구현해야 함.
2. 책에 대한 함수를 구현해야 함
그러나, 구조적 프로그래밍에서는 리턴 값이 없는 두 함수로 나누어져있기 때문에 논리적으로 묶여있을 수 없는 구조이다.
이를 해결하기 위한 패러다임으로 **객체지향 프로그래밍**이 등장하게 된다.

#### 객체지향 프로그래밍의 등장
어떤 개념에 대한 자료형과 함수를 '객체' 형태로 함께 묶어서 관리하기 위해 등장하였다. 핵심 포인트는 객체 내부에 자료형 필드와 함수가 함께 존재한다는 것이다. 가능한 모든 물리적, 논리적 요소를 객체로 만드는 것이 객체지향 프로그래밍이다.<br>
<br>
예시로 들었던 도서관리 프로그램도 객체지향으로 구현한다면 책의 제목, 저자 등의 자료형 필드와 대출하기, 반납하기 등의 메서드를 객체에 한번에 묶어서 관리할 수 있다.
추상적이었던 동작들도 직관적으로 보이게 되고 가독성이 증가하게 된다.
<br>
결론적으로 객체지향 프로그래밍의 사용으로 객체 간의 독립성이 뚜렷하게 생기고, 중복 코드가 대폭 줄어든다. 따라서 **유지보수**에 용이해진다.



## 추상클래스와 인터페이스
우선 추상메서드란, 내용이 없는 메서드 즉, 구현(정의)는 하지않고 선언만 한 메서드이다. 부모 클래스에서 구체화하여 정의할 필요가 없을 때 선언만 하고 자식 클래스에서 재정의하여 사용하도록 한다. 

추상클래스, 인터페이스 둘 다 추상 메서드를 포함 하는 클래스이다. 둘 모두 선언만 있고 구현 내용이 없기에 new를 통해 객체를 생성할 수 없으며, 상속받은 자식만이 인스턴스를 생성할 수 있다. 상속 시 반드시 추상 메서드를 구현해야 한다. ( 추상 클래스에 선언된 일반 메서드는 자식 클래스에서 사용하지 않아도 무방하다. )
차이점은 아래와 같다.
| **추상클래스** | **인터페이스** |
| --- | --- |
| 일반 메서드 포함 가능 | 모든 메서드가 추상 메서드 |
| 일반 변수(Optional) + 일반 메서드(Optional) + 추상 메서드 형태 | 상수 + 추상 메서드 형태 |
| 다중 상속 불가능 | 다중 상속 지원 |
| extends | implements |
| abstract | interface |
| 메서드의 부분적인 구현 가능 | 메서드 선언만 가능 |
> 이러한 차이 때문에 추상클래스는 클래스 확장이 필요할 때 사용하고, 인터페이스는 동일한 기능을 보장할 때 사용한다.









###### 참고자료
- http://tcpschool.com/java/java_intro_basic
- https://velog.io/@haero_kim/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0
- https://private.tistory.com/20
